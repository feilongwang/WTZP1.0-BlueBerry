C51 COMPILER V9.00   CONTROL                                                               08/28/2018 17:24:45 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE CONTROL
OBJECT MODULE PLACED IN .\Output\Control.obj
COMPILER INVOKED BY: E:\Program Files\keil5\C51\BIN\C51.EXE Modules\Control.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJEC
                    -TEXTEND PRINT(.\Listing\Control.lst) TABS(2) OBJECT(.\Output\Control.obj)

line level    source

   1          /*****************************************************************
   2          **                   ´óÁ¬Àí¹¤´óÑ§ ´´ÐÂ´´ÒµÑ§Ôº
   3          **                       ÎïÁªÍøÓ¦ÓÃ¹¤·»
   4          **---------------------------------------------------------------
   5          ** ÏîÄ¿Ãû³Æ£º   WTZP1.0-BlueBerry
   6          ** ÈÕ    ÆÚ£º   2018-07-21
   7          ** ×÷    Õß£º   ÎÂÎä¾ü
   8          **---------------------------------------------------------------
   9          ** ÎÄ ¼þ Ãû£º   Control.c
  10          ** ÎÄ¼þËµÃ÷£º   ±Ã¿ØÖÆ¹¦ÄÜÄ£¿é
  11          *****************************************************************/
  12          /*---------------------INCLUDES----------------------*/
  13          #include "Control.h"
  14          
  15          /*---------------------VARIABLES---------------------*/
  16          /***********************************************************************
  17          ** ²ÎÊýËµÃ÷£º MOS¹ÜµÄ¿ª¹Ø×´Ì¬´¢´æÊý×é£¬MOSHand£¨ÈË¹¤ÏÖ³¡¿ØÖÆÓëÔÆÆ½Ì¨¿ØÖÆ£©£¬MOSAuto£¨ÏµÍ³×Ô¶¯¿ØÖÆ£©£¬0-¹Ø£
             -¬1-¿ª
  18          ***********************************************************************/
  19          uint8 MOSHand[4]={0,0,0,0},MOSAuto[4]={0,0,0,0};
  20          /***********************************************************************
  21          ** ²ÎÊýËµÃ÷£º ¿ØÖÆÏìÓ¦±êÖ¾£¬HighControlAckFlag£¨ÈË¹¤ÏÖ³¡¿ØÖÆÓëÔÆÆ½Ì¨¿ØÖÆ£©£¬ControlAckFlag£¨ÏµÍ³×Ô¶¯¿ØÖÆ£©
             -£¬ControlPrmFlag£¨²ÎÊý¸Ä±ä£©0-ÎÞ£¬1-ÓÐ
  22          ***********************************************************************/
  23          static uint8 HighControlAckFlag=0,ControlAckFlag=0,ControlPrmFlag=1;
  24          char AutoCrolAck[4]={0,0,0,0};
  25          char MOSCntFlag=0;
  26          char MesureMode=0;//1-on 0-off
  27          char AutoControlMode=0;//1-on 0-off
  28          char ControlKeyName[6][15]={"PhControl","BNutAdd","WaterCircule","ANutAdd","data","apitag"};//±Ã¿ØÖÆÊ¶±ðÂë
  29          int16 PrmEC;
  30          int16 PrmPH;
  31          extern uint8 LCDReccount;
  32          extern uint16 Timecount1;
  33          uint16 Timecount1_MOS1=0;//Ã¿Ò»Ãë´¢´æ
  34          uint16 Timecount2_MOS1=0;//Ã¿Ê®Ãë´¢´æ
  35          uint16 Timecount1_MOS2=0;//Ã¿Ò»Ãë´¢´æ
  36          uint16 Timecount2_MOS2=0;//Ã¿Ê®Ãë´¢´æ
  37          uint16 Timecount1_MOS3=0;//Ã¿Ò»Ãë´¢´æ
  38          uint16 Timecount2_MOS3=0;//Ã¿Ê®Ãë´¢´æ
  39          uint16 Timecount1_MOS4=0;//Ã¿Ò»Ãë´¢´æ
  40          uint16 Timecount2_MOS4=0;//Ã¿Ê®Ãë´¢´æ
  41          uint8 MOSTimeCotrol=0;//0000 0000 ¿ªÊ¼¼ÆÊ±1bitMOS1 2bitMOS2 3bitMOS3 4bitMOS4 ¼ÆÊ±Íê³É±êÖ¾Î»5bitMOS1 6bitM
             -OS2 7bitMOS3 8bitMOS4 
  42          uint16 Time_MOS[4][2];//4-MOS¹Ü±àºÅ£¬3-Ê±¼ä£¬Ãë-Ê±(×ª»»³ÉÊ®ÃëÖÆ)
  43          
  44          /*---------------------FUNCTIONS---------------------*/
  45          /*{
  46          MOS1=0;PH
  47          MOS2=0;BÒº
  48          MOS3=0;Ë®Ñ­»·
  49          MOS4=0;AÒº
  50          }*///0 off 1 on
  51          /***********************************************************************
C51 COMPILER V9.00   CONTROL                                                               08/28/2018 17:24:45 PAGE 2   

  52          ** º¯ Êý Ãû£º MOSControl()
  53          ** º¯ÊýËµÃ÷£º MOS¹ÜµÄ¿ØÖÆº¯Êý
  54          **---------------------------------------------------------------------
  55          ** ÊäÈë²ÎÊý£º uint8 MOSNum£¨ÐèÒª´ò¿ªµÄMOSÐòºÅ£©uint8 Switch(¿ª¹Ø×´Ì¬)
  56          ** ·µ»Ø²ÎÊý£º ÎÞ£¬±ÃµÄ×´Ì¬£¬0-¹Ø£¬1-¿ª
  57          ***********************************************************************/
  58          void MOSControl(uint8 MOSNum,uint8 Switch)
  59          {
  60   1        switch(MOSNum)
  61   1        {
  62   2          case 0:MOS1=(!Switch)?0:1;break;
  63   2          case 1:MOS2=(!Switch)?0:1;break;
  64   2          case 2:MOS3=(!Switch)?0:1;break;
  65   2          case 3:MOS4=(!Switch)?0:1;break;
  66   2        }
  67   1      }
  68          /***********************************************************************
  69          ** º¯ Êý Ãû£º MOSArb()
  70          ** º¯ÊýËµÃ÷£º MOS¹ÜµÄ¿ª¹ØÖÙ²Ã
  71          **---------------------------------------------------------------------
  72          ** ÊäÈë²ÎÊý£º uint8 MOSNum£¨ÐèÒªÖÙ²ÃµÄMOSÐòºÅ£©
  73          ** ·µ»Ø²ÎÊý£º uint8,±ÃµÄ×´Ì¬£¬0-¹Ø£¬1-¿ª,FF-Ã»ÓÐ±Ã²Ù×÷
  74          ***********************************************************************/
  75          uint8 MOSArb()
  76          {
  77   1        static uint8 HighInterruptCnt=0;
  78   1        //ÖÙ²ÃÔ­Ôò£ºÈË¹¤ÓëÔÆÆ½Ì¨Í¬Êô×î¸ß¼¶±ðÖÐ¶Ï£¨ÓÉÏÈºóÅÐ¶Ï£©£¬×Ô¶¯¿ØÖÆÊôÓÚµÍ¼¶±ðÖÐ¶Ï
  79   1                  UartSend1_Byte(HighControlAckFlag,1);
  80   1                  UartSend1_Byte(ControlAckFlag,1);
  81   1                  UartSend1_Byte(AutoControlMode,1);
  82   1        if((!HighControlAckFlag)&&ControlAckFlag&&AutoControlMode)//µ±ÔÆÆ½Ì¨ÓëÈË¹¤ÎÞ²Ù×÷Ê±£¬×Ô¶¯¿ØÖÆÏìÓ¦
  83   1        {
  84   2          MOSControl(0,MOSAuto[0]);//¿ØÖÆ±Ã
  85   2          MOSControl(1,MOSAuto[1]);
  86   2          MOSControl(2,MOSAuto[2]);
  87   2          MOSControl(3,MOSAuto[3]);
  88   2          ControlAckFlag=0;//Çå³ý±êÖ¾
  89   2          MOSHand[0]=MOSAuto[0];//Í³Ò»±Ã×´Ì¬
  90   2          MOSHand[1]=MOSAuto[1];
  91   2          MOSHand[2]=MOSAuto[2];
  92   2          MOSHand[3]=MOSAuto[3];
  93   2          return 0;
  94   2        }
  95   1        else if(HighControlAckFlag&ControlAckFlag)//ÔÆÆ½Ì¨»òÕßÈË¹¤²Ù×÷Ê±£¬ÆÁ±Î×Ô¶¯¿ØÖÆÏìÓ¦
  96   1        {
  97   2          MOSControl(0,MOSHand[0]);//¿ØÖÆ±Ã
  98   2          MOSControl(1,MOSHand[1]);
  99   2          MOSControl(2,MOSHand[2]);
 100   2          MOSControl(3,MOSHand[3]);
 101   2          ControlAckFlag=0;//Çå³ý±êÖ¾£¬¸ß¼¶ÖÐ¶Ï²Ù×÷ÔÚÏÂ´Î¸ß¼¶ÖÐ¶Ï²Ù×÷Ê±Çå³ý
 102   2          MOSAuto[0]=MOSHand[0];//Í³Ò»±Ã×´Ì¬
 103   2          MOSAuto[1]=MOSHand[1];
 104   2          MOSAuto[2]=MOSHand[2];
 105   2          MOSAuto[3]=MOSHand[3];
 106   2          HighInterruptCnt++;
 107   2          if(HighInterruptCnt==2)//Çå³ý¸ß¼¶ÖÐ¶Ï±êÖ¾
 108   2          {
 109   3            HighInterruptCnt=0;
 110   3            HighControlAckFlag=0;
 111   3          }
 112   2          return 0;
 113   2        }
C51 COMPILER V9.00   CONTROL                                                               08/28/2018 17:24:45 PAGE 3   

 114   1        else if(!ControlAckFlag)//ÎÞ±Ã²Ù×÷Ê±ÏìÓ¦
 115   1        {
 116   2          return 0XFF;
 117   2        }
 118   1        return 0XFF;
 119   1      }
 120          /***********************************************************************
 121          ** º¯ Êý Ãû£º ControlPrm()
 122          ** º¯ÊýËµÃ÷£º Ö²ÎïÉú³¤¿ØÖÆ²ÎÊýµ÷Õû
 123          **---------------------------------------------------------------------
 124          ** ÊäÈë²ÎÊý£º ÎÞ
 125          ** ·µ»Ø²ÎÊý£º ÎÞ
 126          ***********************************************************************/
 127          void ControlPrm()
 128          {
 129   1        /*PrmEC=IapRead(0x0102);
 130   1        PrmEC=PrmEC<<8;
 131   1        PrmEC=PrmEC|IapRead(0x0101);//»ñÈ¡EC²ÎÊýÖµ
 132   1        PrmPH=IapRead(0x0100);//»ñÈ¡PH²ÎÊý*/
 133   1        PrmPH=0x1388;//5000
 134   1        PrmEC=0x03E8;//1000
 135   1      }
 136          /***********************************************************************
 137          ** º¯ Êý Ãû£º MOSMesRec()
 138          ** º¯ÊýËµÃ÷£º MOS¹Ü¿ØÖÆÊý¾Ý²É¼¯(¶ÔÈË¹¤²Ù×÷ºÍÔÆÆ½Ì¨)
 139          **---------------------------------------------------------------------
 140          ** ÊäÈë²ÎÊý£º ÎÞ
 141          ** ·µ»Ø²ÎÊý£º ÎÞ
 142          ***********************************************************************/
 143          void MOSMesRec()
 144          {
 145   1        char *NetData;
 146   1        char *NetKey;
 147   1        char Ackcmp[4]={0,0,0,0},i,j;
 148   1        char OptionCode;//²Ù×÷Âë
 149   1        i=LCDRec();//½ÓÊÕ±êÖ¾Î»
 150   1        if(i)//ÈË¹¤ÏÖ³¡¿ØÖÆ
 151   1        {
 152   2          LCDAck[LCDReccount]=0;
 153   2          OptionCode=LCDAnalyse();
 154   2          switch(OptionCode)
 155   2          {
 156   3            case 0x10:MOSHand[0]=0;i=0;break;
 157   3            case 0x11:MOSHand[0]=1;i=0;break;
 158   3            case 0x20:MOSHand[1]=0;i=0;break;
 159   3            case 0x21:MOSHand[1]=1;i=0;break;
 160   3            case 0x30:MOSHand[2]=0;i=0;break;
 161   3            case 0x31:MOSHand[2]=1;i=0;break;
 162   3            case 0x40:MOSHand[3]=0;i=0;break;
 163   3            case 0x41:MOSHand[3]=1;i=0;break;
 164   3            case 0xF1:MesureMode=1;break;
 165   3            case 0xF4:MesureMode=0;break;
 166   3            case 0xF2:AutoControlMode=1;HighControlAckFlag=0;MesureMode=0;MOSTimeCotrol=0;ControlAckFlag=0;ControlA
             -ckFlag=1;for(j=0;j<3;j++){AutoCrolAck[j]=0;}TR0=0;Timecount1=0;break;//ËùÓÐ×Ô¶¯¿ØÖÆ±äÁ¿¸´Î»
 167   3            case 0xF3:AutoControlMode=0;break;
 168   3            default:i=0xFF;
 169   3          }
 170   2          LCDAck[1]=0;
 171   2          if(!i)
 172   2          {
 173   3            HighControlAckFlag=1;
 174   3            ControlAckFlag=1;
C51 COMPILER V9.00   CONTROL                                                               08/28/2018 17:24:45 PAGE 4   

 175   3          }
 176   2        }
 177   1        if(Urst2Rec)//ÔÆÆ½Ì¨¿ØÖÆ
 178   1        {
 179   2          
 180   2          NetKey=JsonKeyRec(ControlKeyName[5],WIFIAck);
 181   2          for(i=0;i<4;i++)
 182   2          {
 183   3            OptionCode=JsonKeyCmp(ControlKeyName[i],NetKey);//´Ë´¦ÓÃÓÚº¯Êý·µ»ØÖµÖÐ×ª
 184   3            Ackcmp[i]=!OptionCode;
 185   3            if(Ackcmp[i])
 186   3            {
 187   4              NetData=JsonKeyRec(ControlKeyName[4],WIFIAck)-1;
 188   4              MOSHand[i]=*NetData-0x30;
 189   4              HighControlAckFlag=1;
 190   4              ControlAckFlag=1;
 191   4            }
 192   3          }
 193   2          Urst2Rec=0;
 194   2        }
 195   1      }
 196          /*
 197          void TimeMesRec()
 198          {
 199            char i,cnt=0;
 200            uint16 t1,t2,t3;
 201            if(ControlPrmFlag)//ÈË¹¤ÏÖ³¡¿ØÖÆ
 202            {
 203              //for(i=0;i<3;i++)
 204              {
 205                UartSend1_str(LCDAck+9);
 206                LCDReccount=0;
 207                LCDTypeRead(3,2);
 208                
 209                while(cnt>200)cnt++;cnt=0;
 210                      UartSend1_str(LCDAck+9);
 211                t1=atoi(LCDAck+9);
 212                      LCDReccount=0;
 213                UartSend1_Byte(t1,1);
 214                LCDTypeRead(3,3+i*3);
 215                      while(cnt>200)cnt++;cnt=0;
 216                t2=atoi(LCDAck+8);
 217                UartSend1_Byte(t2,1);
 218                      LCDReccount=0;
 219                LCDTypeRead(3,4+i*3);
 220                      while(cnt>200)cnt++;cnt=0;
 221                t3=atoi(LCDAck+8);
 222                UartSend1_Byte(t3,1);
 223                if((t1+t2+t3)!=0)
 224                {
 225                  TimeConvert(t1,t2,t3,i);
 226                  MOSAuto[i]=1;
 227                  HighControlAckFlag=1;
 228                  ControlAckFlag=1;
 229                }
 230              }
 231              ControlPrmFlag=0;
 232            }
 233          }*/
 234          /***********************************************************************
 235          ** º¯ Êý Ãû£º AutoControl()
 236          ** º¯ÊýËµÃ÷£º ÏµÍ³×Ô¶¯¿ØÖÆ¿ª±Ãº¯Êý
C51 COMPILER V9.00   CONTROL                                                               08/28/2018 17:24:45 PAGE 5   

 237          **---------------------------------------------------------------------
 238          ** ÊäÈë²ÎÊý£º ÎÞ
 239          ** ·µ»Ø²ÎÊý£º ÎÞ
 240          ***********************************************************************/
 241          void AutoControl()
 242          {
 243   1        char i;
 244   1        UartSend1_Byte(AutoCrolAck[0],1);
 245   1        for(i=0;i<3;i++)
 246   1        {
 247   2          if(AutoCrolAck[i]==0)
 248   2          {
 249   3            AutoControlOpen();
 250   3            AutoCrolAck[i]++;
 251   3          }
 252   2        }
 253   1      }
 254          /***********************************************************************
 255          ** º¯ Êý Ãû£º AutoControlOpen()
 256          ** º¯ÊýËµÃ÷£º ÏµÍ³×Ô¶¯¿ØÖÆ¿ª±Ãº¯Êý
 257          **---------------------------------------------------------------------
 258          ** ÊäÈë²ÎÊý£º ÎÞ
 259          ** ·µ»Ø²ÎÊý£º ÎÞ
 260          ***********************************************************************/
 261          void AutoControlOpen()
 262          {
 263   1        char ControlSecond[4]={0,0,0,0},i;//0-MOS1 1-MOS2
 264   1        //char ZFFlag[2];//Êý¾ÝÕý¸º±êÖ¾
 265   1        //char AddLiquidSecond=1.5;//(ml)Ã¿Ò»Ãë¼ÓÈëÈÜÒºµÄÁ¿
 266   1        //char HoldLquidV=1;//(L)ÏµÍ³×ÜÒºÌåÌå»ý
 267   1        uint16 Difference_value[4];//0-MOS1 1-MOS2
 268   1        if(1)
 269   1        {
 270   2          Difference_value[0]=abs(DatePh-PrmPH);
 271   2          /*for(i=0;i<3;i++)
 272   2          {
 273   2            if(Difference_value[i]&80){Difference_value[i]=abs(Difference_value[i]);ZFFlag[i]=1;}
 274   2          }*/
 275   2          if(Difference_value[0]>=500)
 276   2          {
 277   3            ControlSecond[0]=Difference_value[0]/500;
 278   3            TimeConvert(ControlSecond[0],0,0,0);
 279   3            MOSAuto[0]=1;
 280   3            ControlAckFlag=1;
 281   3        UartSend1_Byte(ControlAckFlag,1);
 282   3          }
 283   2          Difference_value[1]=abs(DateEc-PrmEC);
 284   2          if(Difference_value[1]>=400)
 285   2          {
 286   3            ControlSecond[1]=Difference_value[1]/400;
 287   3            TimeConvert(ControlSecond[1],0,0,1);
 288   3            MOSAuto[1]=1;
 289   3            ControlAckFlag=1;
 290   3          }
 291   2          ControlSecond[2]=ControlSecond[0]>=ControlSecond[1]?ControlSecond[0]:ControlSecond[1];
 292   2          if(ControlSecond[2]&&(!AutoCrolAck[2]))
 293   2          {
 294   3            TimeConvert(ControlSecond[2]*10,0,0,2);
 295   3            MOSAuto[2]=1;
 296   3            ControlAckFlag=1;
 297   3          }
 298   2        }
C51 COMPILER V9.00   CONTROL                                                               08/28/2018 17:24:45 PAGE 6   

 299   1      }
*** WARNING C280 IN LINE 263 OF MODULES\CONTROL.C: 'i': unreferenced local variable
 300          /***********************************************************************
 301          ** º¯ Êý Ãû£º TimeConvert()
 302          ** º¯ÊýËµÃ÷£º Ê±¼ä´«µÝº¯Êý
 303          **---------------------------------------------------------------------
 304          ** ÊäÈë²ÎÊý£º uint8 Time_second//Ãë¿ØÖÆ,uint16 Time_mintius//·ÖÖÓ¿ØÖÆ,uint16 Time_hours_MOS1;//Ð¡Ê±¿ØÖÆ,ui
             -nt8 MosN//MOS¹Ü±àºÅ
 305          ** ·µ»Ø²ÎÊý£º ÎÞ
 306          ***********************************************************************/
 307          void TimeConvert(uint8 Time_second,uint16 Time_mintius,uint16 Time_hours,uint8 MosN)
 308          {
 309   1        switch(MosN)
 310   1        {
 311   2          case 0:MOSTimeCotrol|=0x01;TR0=1;Time_MOS[0][0]=Time_second+Time_mintius*60,Time_MOS[0][1]=Time_hours*36
             -0+Time_MOS[0][0]/10;break;//MOS1¼ÆÊ±Æô¶¯
 312   2          case 1:MOSTimeCotrol|=0x02;TR0=1;Time_MOS[1][0]=Time_second+Time_mintius*60,Time_MOS[1][1]=Time_hours*36
             -0+Time_MOS[0][0]/10;break;//MOS2¼ÆÊ±Æô¶¯
 313   2          case 2:MOSTimeCotrol|=0x04;TR0=1;Time_MOS[2][0]=Time_second+Time_mintius*60,Time_MOS[2][1]=Time_hours*36
             -0+Time_MOS[0][0]/10;;break;//MOS3¼ÆÊ±Æô¶¯
 314   2          case 3:MOSTimeCotrol|=0x08;TR0=1;Time_MOS[3][0]=Time_second+Time_mintius*60,Time_MOS[3][1]=Time_hours*36
             -0+Time_MOS[0][0]/10;break;//MOS4¼ÆÊ±Æô¶¯
 315   2        }
 316   1      }
 317          /***********************************************************************
 318          ** º¯ Êý Ãû£º TimeCnt()
 319          ** º¯ÊýËµÃ÷£º Ê±¼ä¼ÆËãº¯Êý
 320          **---------------------------------------------------------------------
 321          ** ÊäÈë²ÎÊý£º ÎÞ
 322          ** ·µ»Ø²ÎÊý£º ÎÞ
 323          ***********************************************************************/
 324          void TimeCnt()
 325          {
 326   1        if(MOSTimeCotrol)
 327   1        {
 328   2          if(MOSTimeCotrol&0x01)
 329   2          {
 330   3            if(MOSCntFlag&0x01&&MOSCntFlag&0x10)
 331   3            {MOSTimeCotrol|=0x10;MOSCntFlag=0;}
 332   3          }
 333   2          if(MOSTimeCotrol&0x02)
 334   2          {
 335   3            if(MOSCntFlag&0x02&&MOSCntFlag&0x20)
 336   3            {MOSTimeCotrol|=0x20;MOSCntFlag=0;}
 337   3          }
 338   2          if(MOSTimeCotrol&0x04)
 339   2          {
 340   3            if(MOSCntFlag&0x04&&MOSCntFlag&0x40)
 341   3            {MOSTimeCotrol|=0x40;MOSCntFlag=0;}
 342   3          }
 343   2          if(MOSTimeCotrol&0x08)
 344   2          {
 345   3            if(MOSCntFlag&0x08&&MOSCntFlag&0x80)
 346   3            {MOSTimeCotrol|=0x80;MOSCntFlag=0;}
 347   3          }
 348   2        }
 349   1      }
 350          /***********************************************************************
 351          ** º¯ Êý Ãû£º AutoContolClose()
 352          ** º¯ÊýËµÃ÷£º ÏµÍ³×Ô¶¯¿ØÖÆ¹Ø±Ãº¯Êý
 353          **---------------------------------------------------------------------
 354          ** ÊäÈë²ÎÊý£º ÎÞ
C51 COMPILER V9.00   CONTROL                                                               08/28/2018 17:24:45 PAGE 7   

 355          ** ·µ»Ø²ÎÊý£º ÎÞ
 356          ***********************************************************************/
 357          void AutoContolClose()
 358          {
 359   1        TimeCnt();
 360   1        if(MOSTimeCotrol)
 361   1        {
 362   2          if(MOSTimeCotrol&0x10)
 363   2          {
 364   3            MOSAuto[0]=0;
 365   3            MOSTimeCotrol=MOSTimeCotrol&0xEE;
 366   3            Timecount1_MOS1=0;Timecount2_MOS1=0;
 367   3            if(MOSTimeCotrol&0x40)
 368   3            {
 369   4                AutoCrolAck[0]=0;
 370   4            }
 371   3            ControlAckFlag=1;
 372   3          }
 373   2          if(MOSTimeCotrol&0x20)
 374   2          {
 375   3            MOSAuto[1]=0;
 376   3            MOSTimeCotrol=MOSTimeCotrol&0xDD;
 377   3            Timecount1_MOS2=0;Timecount2_MOS2=0;
 378   3            if(MOSTimeCotrol&0x40)
 379   3            {
 380   4                AutoCrolAck[1]=0;
 381   4            }
 382   3            ControlAckFlag=1;
 383   3          }
 384   2          if(MOSTimeCotrol&0x40)
 385   2          {
 386   3            MOSAuto[2]=0;
 387   3            MOSTimeCotrol=MOSTimeCotrol&0xBB;
 388   3            Timecount1_MOS3=0;Timecount2_MOS3=0;
 389   3            AutoCrolAck[2]=0;
 390   3            ControlAckFlag=1;
 391   3          }
 392   2          if(MOSTimeCotrol&0x80)
 393   2          {
 394   3            MOSAuto[3]=0;
 395   3            MOSTimeCotrol=MOSTimeCotrol&0x77;
 396   3            Timecount1_MOS4=0;Timecount2_MOS4=0;
 397   3            AutoCrolAck[3]=0;
 398   3            ControlAckFlag=1;
 399   3          }
 400   2          if(!MOSTimeCotrol){TR0=0;MesureMode=1;}
 401   2        }
 402   1      }
 403          /***********************************************************************
 404          ** º¯ Êý Ãû£º AsmControl()
 405          ** º¯ÊýËµÃ÷£º ¿ØÖÆÏµÍ³×Üº¯Êý
 406          **---------------------------------------------------------------------
 407          ** ÊäÈë²ÎÊý£º ÎÞ
 408          ** ·µ»Ø²ÎÊý£º ÎÞ
 409          ***********************************************************************/
 410          void AsmControl()//¿ØÖÆË³ÐòºÜÖØÒª
 411          {
 412   1        if(ControlPrmFlag)//²é¿´Ö²ÎïÉú³¤²ÎÊýÊÇ·ñ¸Ä±ä
 413   1        {
 414   2          ControlPrm();
 415   2          ControlPrmFlag=0;
 416   2        }
C51 COMPILER V9.00   CONTROL                                                               08/28/2018 17:24:45 PAGE 8   

 417   1        MOSMesRec();//ÆäËû¿ØÖÆÖ¸Áî
 418   1        //TimeMesRec();
 419   1        if(AutoControlMode)
 420   1        {
 421   2          AutoControl();//×Ô¶¯¿ØÖÆÖ¸Áî
 422   2          AutoContolClose();
 423   2        }
 424   1        MOSArb();//MOS¹Ü¿ØÖÆÖÙ²Ã
 425   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1856    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =    146      29
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
